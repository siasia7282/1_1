//[lighting line] [System (2)] Output Particle Point,5
//Don't delete the previous line or this one
Shader "Hidden/VFX/lighting line/System (2)/Output Particle Point"
{
	SubShader
	{
	    Tags{ "RenderPipeline" = "HDRenderPipeline" }
		Tags { "Queue"="Geometry+0" "IgnoreProjector"="False" "RenderType"="Opaque" }
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		// Strips tangent computation
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		ZTest LEqual
		ZWrite On
		Cull Off
		

		
		HLSLINCLUDE
		#pragma only_renderers d3d11 metal vulkan xboxone xboxone xboxseries playstation ps5
		
		#pragma enable_d3d11_debug_symbols
		
		#define NB_THREADS_PER_GROUP 64
		#define HAS_VFX_ATTRIBUTES 1
		#define VFX_PASSDEPTH_ACTUAL (0)
		#define VFX_PASSDEPTH_MOTION_VECTOR (1)
		#define VFX_PASSDEPTH_SELECTION (2)
		#define VFX_PASSDEPTH_PICKING (3)
		#define VFX_PASSDEPTH_SHADOW (4)
		#define VFX_USE_POSITION_CURRENT 1
		#define VFX_USE_COLOR_CURRENT 1
		#define VFX_USE_ALPHA_CURRENT 1
		#define VFX_USE_ALIVE_CURRENT 1
		#define VFX_USE_OLDPOSITION_CURRENT 1
		#define RAW_CAPACITY 30000u
		#define VFX_COLORMAPPING_DEFAULT 1
		#define IS_OPAQUE_PARTICLE 1
		#define VFX_BYPASS_EXPOSURE 1
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		#define VFX_LOCAL_SPACE 1
		#include_with_pragmas "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXDefines.hlsl"
		#define VFX_USE_GRAPH_VALUES 1
		#define VFX_USE_INSTANCING 1
		#define VFX_INSTANCING_FIXED_SIZE 30000
		#pragma multi_compile_instancing
		

		
		struct GraphValues
		{
		    bool _vfx_enabled_l;
		    float3 _Color_a;
		};
		ByteAddressBuffer graphValuesBuffer;
		
		
		
		struct VFXAttributes
		{
		    float3 position;
		    float3 color;
		    float alpha;
		    bool alive;
		    float3 oldPosition;
		};
		
		struct VFXSourceAttributes
		{
		};
		
		

		
		#define VFX_NEEDS_COLOR_INTERPOLATOR (VFX_USE_COLOR_CURRENT || VFX_USE_ALPHA_CURRENT)
		#if HAS_STRIPS
		#define VFX_OPTIONAL_INTERPOLATION
		#else
		#define VFX_OPTIONAL_INTERPOLATION nointerpolation
		#endif
		
		#if VFX_USE_INSTANCING
		#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX nointerpolation uint2 instanceIndices : INDEX0; //instanceCurrentIndex, instanceActiveIndex
		#define VFX_VARYINGS_INSTANCE_CURRENT_INDEX instanceIndices.x
		#define VFX_VARYINGS_INSTANCE_ACTIVE_INDEX instanceIndices.y
		#ifdef UNITY_INSTANCING_ENABLED
		    #define VFX_FRAG_SETUP_INSTANCE_ID(i) unity_InstanceID = i.VFX_VARYINGS_INSTANCE_CURRENT_INDEX
		#else
		    #define VFX_FRAG_SETUP_INSTANCE_ID(i)
		#endif
		#else
		#define VFX_VERTEX_OUTPUT_INSTANCE_INDEX
		#endif
		
		ByteAddressBuffer attributeBuffer;
		
		#if VFX_HAS_INDIRECT_DRAW
		StructuredBuffer<uint> indirectBuffer;
		#endif
		
		#if USE_DEAD_LIST_COUNT
		StructuredBuffer<uint> deadList;
		#endif
		
		#if HAS_STRIPS_DATA
		StructuredBuffer<uint> stripDataBuffer;
		#endif
		
		#if VFX_FEATURE_MOTION_VECTORS
		ByteAddressBuffer elementToVFXBufferPrevious;
		
		#if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)
		
		#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
		noperspective float4 cPosPreviousAndNonJiterred : TEXCOORD##coordA;
		
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPreviousAndNonJiterred.xy
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosPreviousAndNonJiterred.zw
		
		#else
		
		#define VFX_DECLARE_MOTION_VECTORS_STORAGE(coordA, coordB)\
		float4 cPosPrevious : TEXCOORD##coordA;\
		float4 cPosNonJiterred : TEXCOORD##coordB;
		
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS cPosPrevious
		#define VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER cPosNonJiterred
		
		#endif
		#endif
		
		CBUFFER_START(outputParamsConst)
		    
		    		float4 instancingConstants;
		    		uint2 instancingBufferOffsets;
		    		
		    float3 cameraXRSettings;
		CBUFFER_END
		
		UNITY_INSTANCING_BUFFER_START(PerInstance)
		    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceIndex)
		    UNITY_DEFINE_INSTANCED_PROP(float, _InstanceActiveIndex)
		UNITY_INSTANCING_BUFFER_END(PerInstance)
		
		// Helper macros to always use a valid instanceID
		#if defined(UNITY_STEREO_INSTANCING_ENABLED)
			#define VFX_DECLARE_INSTANCE_ID     UNITY_VERTEX_INPUT_INSTANCE_ID
			#define VFX_GET_INSTANCE_ID(i)      unity_InstanceID
		#else
			#define VFX_DECLARE_INSTANCE_ID     uint instanceID : SV_InstanceID;
			#define VFX_GET_INSTANCE_ID(i)      i.instanceID
		#endif
		
		ENDHLSL
		

		// Depth pass
		Pass
		{
		    Name "SceneSelectionPass"
			Tags { "LightMode"="SceneSelectionPass" }
		
			ZWrite On
			Blend Off
		
			HLSLPROGRAM
			#define VFX_PASSDEPTH VFX_PASSDEPTH_SELECTION
			
			#pragma target 4.5
			
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
				nointerpolation float2 builtInInterpolants : TEXCOORD0;
				#endif
			
				#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
				VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
				#endif
			
				float pointSize : PSIZE;
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#undef VFX_VARYING_COLOR // Not used
			#define VFX_VARYING_ALPHA builtInInterpolants.x
			#undef VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define SHADERPASS SHADERPASS_MOTION_VECTORS
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
			
					#define SHADERPASS SHADERPASS_DEPTH_ONLY
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					#define SCENESELECTIONPASS
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					#define SCENEPICKINGPASS
					#endif
					
					
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_FDD06EC7(inout float3 color, float3 _Color) /*channels:XYZ */
			{
			    color = _Color;
			}
			

			
			struct vs_input
			{
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			
			VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
			{
				VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = id;
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				GraphValues graphValues;
				
				graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
				graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
				

			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 240);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				if (graphValues._vfx_enabled_l)
				{
				    SetAttribute_FDD06EC7( /*inout */attributes.color, graphValues._Color_a);
				}
				

			
				if (!attributes.alive)
				{
					o.pos.x = VFX_NAN;
					return o; // cull
				}
			
				float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
				float3 vPos = attributes.position;
				o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
				
			
			    o.pointSize = 1;
			
				return o;
			}
			
			
			#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
			
					
					#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
					#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
					#endif
					
					#ifdef VFX_SHADERGRAPH
						#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
						
						#else
						
						#endif
					#endif
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					int _ObjectId;
					int _PassValue;
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					float4 _SelectionID;
					#endif
					
					#pragma fragment frag
					void frag(ps_input i
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
					    #ifdef WRITE_MSAA_DEPTH
					    // We need the depth color as SV_Target0 for alpha to coverage
					    , out float4 outDepthColor : SV_Target0
					    , out float4 outMotionVector : SV_Target1
					    #else
					    // When no MSAA, the motion vector is always the first buffer
					    , out float4 outMotionVector : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
					    #if defined(WRITE_MSAA_DEPTH)
						#if defined(WRITE_NORMAL_BUFFER)
						#error Unexpected depth setup mssa + depth normal
						#endif
					    , out float4 outDepthColor : SV_Target0
					    #elif defined(WRITE_NORMAL_BUFFER)
						, out float4 outNormalBuffer : SV_Target0
						#else
					    , out float4 dummy : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					    , out float4 outSelection : SV_Target0
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
					    , out float4 dummy : SV_Target0
					#endif
					)
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
						VFXTransformPSInputs(i);
						
					
					    #ifdef VFX_SHADERGRAPH
					        
							#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
							
							#else
							
							#endif
					        float alpha = OUTSG.;
					    #else
					        float alpha = VFXGetFragmentColor(i).a;
							#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
								#ifdef VFX_PROCEDURAL_UV
									alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
								#else
									alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
								#endif
							#endif
					    #endif
						VFXClipFragmentColor(alpha,i);
					
						#ifdef WRITE_MSAA_DEPTH
							outDepthColor = i.VFX_VARYING_POSCS.z;
							#if VFX_USE_ALPHA_TO_MASK
								outDepthColor.a = alpha;
							#endif
						#endif
					
						#ifdef WRITE_NORMAL_BUFFER
							#ifdef VFX_VARYING_NORMAL
								VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
							#else
								//Fallback for point and lines, render normal as if those are face camera plane
								VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
							#endif
						#endif
					
						#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
							
									
									//No w division with fast path of motion vectors
									#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
									float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
									#else
									float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
									#endif
									
									#if UNITY_UV_STARTS_AT_TOP
										velocity.y = -velocity.y;
									#endif
									float4 encodedMotionVector = 0.0f;
									VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
									
							outMotionVector = encodedMotionVector;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
							outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
							outSelection = _SelectionID;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
							#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
							    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
							#endif
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
							dummy = (float4)0;
						#else
							#error VFX_PASSDEPTH undefined
						#endif
					}
					
			
		
			ENDHLSL
		}
		
		Pass
		{
		    Name "Picking"
			Tags { "LightMode"="Picking" }
		
			ZWrite On
			Blend Off
		
			HLSLPROGRAM
			#define VFX_PASSDEPTH VFX_PASSDEPTH_PICKING
			
			#pragma target 4.5
			
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
				nointerpolation float2 builtInInterpolants : TEXCOORD0;
				#endif
			
				#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
				VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
				#endif
			
				float pointSize : PSIZE;
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#undef VFX_VARYING_COLOR // Not used
			#define VFX_VARYING_ALPHA builtInInterpolants.x
			#undef VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define SHADERPASS SHADERPASS_MOTION_VECTORS
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
			
					#define SHADERPASS SHADERPASS_DEPTH_ONLY
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					#define SCENESELECTIONPASS
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					#define SCENEPICKINGPASS
					#endif
					
					
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_FDD06EC7(inout float3 color, float3 _Color) /*channels:XYZ */
			{
			    color = _Color;
			}
			

			
			struct vs_input
			{
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			
			VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
			{
				VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = id;
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				GraphValues graphValues;
				
				graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
				graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
				

			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 240);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				if (graphValues._vfx_enabled_l)
				{
				    SetAttribute_FDD06EC7( /*inout */attributes.color, graphValues._Color_a);
				}
				

			
				if (!attributes.alive)
				{
					o.pos.x = VFX_NAN;
					return o; // cull
				}
			
				float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
				float3 vPos = attributes.position;
				o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
				
			
			    o.pointSize = 1;
			
				return o;
			}
			
			
			#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
			
					
					#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
					#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
					#endif
					
					#ifdef VFX_SHADERGRAPH
						#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
						
						#else
						
						#endif
					#endif
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					int _ObjectId;
					int _PassValue;
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					float4 _SelectionID;
					#endif
					
					#pragma fragment frag
					void frag(ps_input i
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
					    #ifdef WRITE_MSAA_DEPTH
					    // We need the depth color as SV_Target0 for alpha to coverage
					    , out float4 outDepthColor : SV_Target0
					    , out float4 outMotionVector : SV_Target1
					    #else
					    // When no MSAA, the motion vector is always the first buffer
					    , out float4 outMotionVector : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
					    #if defined(WRITE_MSAA_DEPTH)
						#if defined(WRITE_NORMAL_BUFFER)
						#error Unexpected depth setup mssa + depth normal
						#endif
					    , out float4 outDepthColor : SV_Target0
					    #elif defined(WRITE_NORMAL_BUFFER)
						, out float4 outNormalBuffer : SV_Target0
						#else
					    , out float4 dummy : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					    , out float4 outSelection : SV_Target0
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
					    , out float4 dummy : SV_Target0
					#endif
					)
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
						VFXTransformPSInputs(i);
						
					
					    #ifdef VFX_SHADERGRAPH
					        
							#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
							
							#else
							
							#endif
					        float alpha = OUTSG.;
					    #else
					        float alpha = VFXGetFragmentColor(i).a;
							#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
								#ifdef VFX_PROCEDURAL_UV
									alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
								#else
									alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
								#endif
							#endif
					    #endif
						VFXClipFragmentColor(alpha,i);
					
						#ifdef WRITE_MSAA_DEPTH
							outDepthColor = i.VFX_VARYING_POSCS.z;
							#if VFX_USE_ALPHA_TO_MASK
								outDepthColor.a = alpha;
							#endif
						#endif
					
						#ifdef WRITE_NORMAL_BUFFER
							#ifdef VFX_VARYING_NORMAL
								VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
							#else
								//Fallback for point and lines, render normal as if those are face camera plane
								VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
							#endif
						#endif
					
						#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
							
									
									//No w division with fast path of motion vectors
									#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
									float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
									#else
									float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
									#endif
									
									#if UNITY_UV_STARTS_AT_TOP
										velocity.y = -velocity.y;
									#endif
									float4 encodedMotionVector = 0.0f;
									VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
									
							outMotionVector = encodedMotionVector;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
							outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
							outSelection = _SelectionID;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
							#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
							    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
							#endif
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
							dummy = (float4)0;
						#else
							#error VFX_PASSDEPTH undefined
						#endif
					}
					
			
		
			ENDHLSL
		}
		

		// Depth pass
		Pass
		{
		    Name "DepthForwardOnly"
			Tags { "LightMode"="DepthForwardOnly" }
		
			ZWrite On
			Blend Off
		
			HLSLPROGRAM
			#define VFX_PASSDEPTH VFX_PASSDEPTH_ACTUAL
			#pragma multi_compile _ WRITE_MSAA_DEPTH
			
			#pragma target 4.5
			
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if USE_ALPHA_TEST || VFX_USE_ALPHA_CURRENT
				nointerpolation float2 builtInInterpolants : TEXCOORD0;
				#endif
			
				#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
				VFX_DECLARE_MOTION_VECTORS_STORAGE(1,2)
				#endif
			
				float pointSize : PSIZE;
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#undef VFX_VARYING_COLOR // Not used
			#define VFX_VARYING_ALPHA builtInInterpolants.x
			#undef VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
			#define SHADERPASS SHADERPASS_MOTION_VECTORS
			#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL || VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
			
					#define SHADERPASS SHADERPASS_DEPTH_ONLY
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					#define SCENESELECTIONPASS
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					#define SCENEPICKINGPASS
					#endif
					
					
			#endif
			
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_FDD06EC7(inout float3 color, float3 _Color) /*channels:XYZ */
			{
			    color = _Color;
			}
			

			
			struct vs_input
			{
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			
			VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
			{
				VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = id;
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				GraphValues graphValues;
				
				graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
				graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
				

			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 240);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				if (graphValues._vfx_enabled_l)
				{
				    SetAttribute_FDD06EC7( /*inout */attributes.color, graphValues._Color_a);
				}
				

			
				if (!attributes.alive)
				{
					o.pos.x = VFX_NAN;
					return o; // cull
				}
			
				float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
				float3 vPos = attributes.position;
				o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
				
			
			    o.pointSize = 1;
			
				return o;
			}
			
			
			#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
			
					
					#ifndef VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
					#define VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH 0
					#endif
					
					#ifdef VFX_SHADERGRAPH
						#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
						
						#else
						
						#endif
					#endif
					
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
					int _ObjectId;
					int _PassValue;
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					float4 _SelectionID;
					#endif
					
					#pragma fragment frag
					void frag(ps_input i
					#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
					    #ifdef WRITE_MSAA_DEPTH
					    // We need the depth color as SV_Target0 for alpha to coverage
					    , out float4 outDepthColor : SV_Target0
					    , out float4 outMotionVector : SV_Target1
					    #else
					    // When no MSAA, the motion vector is always the first buffer
					    , out float4 outMotionVector : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
					    #if defined(WRITE_MSAA_DEPTH)
						#if defined(WRITE_NORMAL_BUFFER)
						#error Unexpected depth setup mssa + depth normal
						#endif
					    , out float4 outDepthColor : SV_Target0
					    #elif defined(WRITE_NORMAL_BUFFER)
						, out float4 outNormalBuffer : SV_Target0
						#else
					    , out float4 dummy : SV_Target0
					    #endif
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION || VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
					    , out float4 outSelection : SV_Target0
					#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
					    , out float4 dummy : SV_Target0
					#endif
					)
					{
						UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
						VFXTransformPSInputs(i);
						
					
					    #ifdef VFX_SHADERGRAPH
					        
							#if (SHADERPASS == SHADERPASS_DEPTHNORMALSONLY)
							
							#else
							
							#endif
					        float alpha = OUTSG.;
					    #else
					        float alpha = VFXGetFragmentColor(i).a;
							#if VFX_SUPPORT_MAIN_TEXTURE_SAMPLING_IN_FRAGMENT_DEPTH
								#ifdef VFX_PROCEDURAL_UV
									alpha *= VFXGetTextureColorWithProceduralUV(VFX_SAMPLER(mainTexture),i,VFX_PROCEDURAL_UV(i)).a;
								#else
									alpha *= VFXGetTextureColor(VFX_SAMPLER(mainTexture),i).a;
								#endif
							#endif
					    #endif
						VFXClipFragmentColor(alpha,i);
					
						#ifdef WRITE_MSAA_DEPTH
							outDepthColor = i.VFX_VARYING_POSCS.z;
							#if VFX_USE_ALPHA_TO_MASK
								outDepthColor.a = alpha;
							#endif
						#endif
					
						#ifdef WRITE_NORMAL_BUFFER
							#ifdef VFX_VARYING_NORMAL
								VFXComputePixelOutputToNormalBuffer(i, normalWS, GetUVData(i), outNormalBuffer);
							#else
								//Fallback for point and lines, render normal as if those are face camera plane
								VFXComputePixelOutputToNormalBuffer(i, VFXGetWorldToViewRotMatrix()[2], GetUVData(i), outNormalBuffer);
							#endif
						#endif
					
						#if VFX_PASSDEPTH == VFX_PASSDEPTH_MOTION_VECTOR
							
									
									//No w division with fast path of motion vectors
									#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
									float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
									#else
									float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
									#endif
									
									#if UNITY_UV_STARTS_AT_TOP
										velocity.y = -velocity.y;
									#endif
									float4 encodedMotionVector = 0.0f;
									VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
									
							outMotionVector = encodedMotionVector;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SELECTION
							outSelection = float4(_ObjectId, _PassValue, 1.0, 1.0);
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_PICKING
							outSelection = _SelectionID;
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_ACTUAL
							#if !defined(WRITE_MSAA_DEPTH) && !defined(WRITE_NORMAL_BUFFER)
							    dummy = float4(i.VFX_VARYING_POSCS.z, 0,0,0);
							#endif
						#elif VFX_PASSDEPTH == VFX_PASSDEPTH_SHADOW
							dummy = (float4)0;
						#else
							#error VFX_PASSDEPTH undefined
						#endif
					}
					
			
		
			ENDHLSL
		}
		

		
		// Forward pass
		Pass
		{
		    Name "ForwardOnly"
			Tags { "LightMode"="ForwardOnly" }
		
			
		
			HLSLPROGRAM
			#pragma target 4.5
			#pragma multi_compile _ DEBUG_DISPLAY
		
			struct ps_input
			{
				float4 pos : SV_POSITION;
				#if VFX_NEEDS_COLOR_INTERPOLATOR
				nointerpolation float4 color : COLOR0;
				#endif
				#if USE_SOFT_PARTICLE || USE_ALPHA_TEST || USE_EXPOSURE_WEIGHT || VFX_FEATURE_MOTION_VECTORS_FORWARD
				nointerpolation float3 builtInInterpolants : TEXCOORD0;
				#endif
				#if VFX_NEEDS_POSWS_INTERPOLATOR
				float3 posWS : TEXCOORD1;
				#endif
			
				#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				VFX_DECLARE_MOTION_VECTORS_STORAGE(2,3)
				#endif
			
				float pointSize : PSIZE;
			
				UNITY_VERTEX_OUTPUT_STEREO
			
			    VFX_VERTEX_OUTPUT_INSTANCE_INDEX
			};
			
			struct ps_output
			{
				float4 color : SV_Target0;
				#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				float4 motionVector : SV_Target1;
				#endif
			};
			
			#define VFX_VARYING_PS_INPUTS ps_input
			#define VFX_VARYING_POSCS pos
			#define VFX_VARYING_COLOR color.rgb
			#define VFX_VARYING_ALPHA color.a
			#define VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE builtInInterpolants.x
			#define VFX_VARYING_ALPHATHRESHOLD builtInInterpolants.y
			#if VFX_NEEDS_POSWS_INTERPOLATOR
			#define VFX_VARYING_POSWS posWS
			#endif
			#if USE_EXPOSURE_WEIGHT
			#define VFX_VARYING_EXPOSUREWEIGHT builtInInterpolants.z
			#endif
			#if VFX_FEATURE_MOTION_VECTORS_FORWARD
			#define VFX_VARYING_VELOCITY_CPOS VFX_DECLARE_MOTION_VECTORS_VARYING_NONJITTER
			#define VFX_VARYING_VELOCITY_CPOS_PREVIOUS VFX_DECLARE_MOTION_VECTORS_VARYING_PREVIOUS
			#endif
			
			#define SHADERPASS SHADERPASS_FORWARD_UNLIT
			#if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
			#error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
			#endif
			
			#include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
			#include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
			

			void SetAttribute_FDD06EC7(inout float3 color, float3 _Color) /*channels:XYZ */
			{
			    color = _Color;
			}
			

			
			struct vs_input
			{
				VFX_DECLARE_INSTANCE_ID
			};
			
			#pragma vertex vert
			
			VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
			{
				VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
			
				UNITY_SETUP_INSTANCE_ID(i);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
			
				uint index = id;
			
				
						uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
						index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
						
				GraphValues graphValues;
				
				graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
				graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
				

			
				struct ContextData
				{
				    uint maxParticleCount;
				    uint systemSeed;
				    uint initSpawnIndex;
				};
				ContextData contextData;
				uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 240);
				contextData.maxParticleCount = rawContextData.x;
				contextData.systemSeed = rawContextData.y;
				contextData.initSpawnIndex = rawContextData.z;
				

				uint systemSeed = contextData.systemSeed;
				uint nbMax = contextData.maxParticleCount;
			
				
						#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
							// We render one particle less for each strip in this case
							nbMax -= STRIP_COUNT;
						#endif
						
						uint deadCount = 0;
						#if USE_DEAD_LIST_COUNT
						deadCount = deadList[instanceIndex];
						#endif
						#if VFX_USE_INSTANCING
						if (index >= nbMax - deadCount)
						#else
						if (index >= asuint(nbMax) - deadCount)
						#endif
						{
							CULL_VERTEX(o);
						}
						
						VFXAttributes attributes = (VFXAttributes)0;
						VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
						
						#if VFX_HAS_INDIRECT_DRAW
						if (index >= indirectBuffer[instanceActiveIndex])
						{
							CULL_VERTEX(o);
						}
						index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
						#endif
						
						#if HAS_STRIPS_DATA
						StripData stripData;
						uint relativeIndexInStrip = 0;
						if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
						{
							CULL_VERTEX(o);
						}
						#endif
						
						#if VFX_HAS_INDIRECT_DRAW
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#else
						attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
						
				
						#if !HAS_STRIPS
						if (!attributes.alive)
						{
							CULL_VERTEX(o);
						}
						#endif
						
						attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
						attributes.color = float3(1, 1, 1);
						attributes.alpha = (float)1;
						attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
						
				
						#endif
						
						// Initialize built-in needed attributes
						#if HAS_STRIPS_DATA
						InitStripAttributes(index, attributes, stripData);
						#endif
						
				if (graphValues._vfx_enabled_l)
				{
				    SetAttribute_FDD06EC7( /*inout */attributes.color, graphValues._Color_a);
				}
				

			
				if (!attributes.alive)
				{
					o.pos.x = VFX_NAN;
					return o; // cull
				}
			
				float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
				float3 vPos = attributes.position;
				o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
			
				
						#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
						#else
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
						#endif
						
						
						uint elementToVFXBaseIndex;
						if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
						{
						float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
						
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
							o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
						#else
							float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
							float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
							o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
							o.VFX_VARYING_VELOCITY_CPOS = cPos;
						#endif
						
						}
						#endif
						
				
						#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
						o.VFX_VARYING_COLOR = attributes.color;
						#endif
						#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
						o.VFX_VARYING_ALPHA = attributes.alpha;
						#endif
						
						#ifdef VFX_VARYING_EXPOSUREWEIGHT
						
						o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
						#endif
						
						#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
						
						o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
						#endif
						
						#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
						
						o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
						#endif
						
						#if USE_UV_SCALE_BIAS
						
						
						#if defined (VFX_VARYING_UV)
						o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
						#endif
						#endif
						
						#ifdef VFX_VARYING_ANGLEFADE
						
						o.VFX_VARYING_ANGLEFADE = angleFade;
						#endif
						
						#ifdef VFX_VARYING_FADEFACTOR
						
						o.VFX_VARYING_FADEFACTOR = fadeFactor;
						#endif
						
						#ifdef VFX_VARYING_DECALLAYER
						
						o.VFX_VARYING_DECALLAYER = decalLayerMask;
						#endif
						
						#if defined(VFX_VARYING_POSWS)
						o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
						#endif
						
						#if VFX_USE_INSTANCING
						    #ifdef UNITY_INSTANCING_ENABLED
						    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
						    #endif
						o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
						#endif
						
				
			
			    o.pointSize = 1;
			
				return o;
			}
			
			
			
			#pragma fragment frag
			ps_output frag(ps_input i)
			{
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
				VFXTransformPSInputs(i);
			
			#if VFX_USE_GRAPH_VALUES
			    uint instanceActiveIndex = i.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX;
			    GraphValues graphValues;
			    
			    graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
			    graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
			    

			#endif
			
				ps_output o = (ps_output)0;
				
						
						float4 color = VFXGetFragmentColor(i);
						
						#ifndef VFX_TEXTURE_COLOR
							#define VFX_TEXTURE_COLOR float4(1.0,1.0,1.0,1.0)
						#endif
						
						#if VFX_COLORMAPPING_DEFAULT
							o.color = color * VFX_TEXTURE_COLOR;
						#endif
						
						#if VFX_COLORMAPPING_GRADIENTMAPPED
							
							o.color = SampleGradient(gradient, VFX_TEXTURE_COLOR.a * color.a) * float4(color.rgb,1.0);
						#endif
						
						
				o.color = VFXApplyPreExposure(o.color, i);
				o.color = VFXApplyAO(o.color,i);
				o.color = VFXApplyFog(o.color,i);
				VFXClipFragmentColor(o.color.a,i);
				o.color.a = saturate(o.color.a);
				o.color = VFXTransformFinalColor(o.color,i);
				#if VFX_FEATURE_MOTION_VECTORS_FORWARD
				
						
						//No w division with fast path of motion vectors
						#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
						float2 velocity = i.VFX_VARYING_VELOCITY_CPOS - i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS;
						#else
						float2 velocity = (i.VFX_VARYING_VELOCITY_CPOS.xy/i.VFX_VARYING_VELOCITY_CPOS.w) - (i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.xy/i.VFX_VARYING_VELOCITY_CPOS_PREVIOUS.w);
						#endif
						
						#if UNITY_UV_STARTS_AT_TOP
							velocity.y = -velocity.y;
						#endif
						float4 encodedMotionVector = 0.0f;
						VFXEncodeMotionVector(velocity * 0.5f, encodedMotionVector);
						
				o.motionVector = encodedMotionVector;
				o.motionVector.a = o.color.a < i.VFX_VARYING_ALPHATHRESHOLD ? 0.0f : 1.0f; //Independant clipping for motion vector pass
				#endif
			
			    
			
				return o;
			}
			
		
			ENDHLSL
		}
		

		Pass
		{
		    Name "FullScreenDebug"
		    Tags{ "LightMode" = "FullScreenDebug" }
		    
		    HLSLPROGRAM
		    #pragma target 4.5
		    #define DEBUG_DISPLAY
		    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
		    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl"
		    
		    struct ps_input
		    {
		        float4 pos : SV_POSITION;
		        float pointSize : PSIZE;
		        UNITY_VERTEX_OUTPUT_STEREO
		        VFX_VERTEX_OUTPUT_INSTANCE_INDEX
		    };
		    
		    #define VFX_VARYING_PS_INPUTS ps_input
		    #define VFX_VARYING_POSCS pos
		
		    
		
		    #if !(defined(VFX_VARYING_PS_INPUTS) && defined(VFX_VARYING_POSCS))
		    #error VFX_VARYING_PS_INPUTS and VFX_VARYING_POSCS must be defined.
		    #endif
		    
		    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/VFXGraph/Shaders/VFXCommon.hlsl"
		    #include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommon.hlsl"
		    #include "Packages/com.unity.visualeffectgraph/Shaders/VFXCommonOutput.hlsl"
		    

		    void SetAttribute_FDD06EC7(inout float3 color, float3 _Color) /*channels:XYZ */
		    {
		        color = _Color;
		    }
		    

		    
		    struct vs_input
		    {
		    	VFX_DECLARE_INSTANCE_ID
		    };
		    
		    #pragma vertex vert
		    
		    VFX_VARYING_PS_INPUTS vert(uint id : SV_VertexID, vs_input i)
		    {
		    	VFX_VARYING_PS_INPUTS o = (VFX_VARYING_PS_INPUTS)0;
		    
		    	UNITY_SETUP_INSTANCE_ID(i);
		    	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
		    
		    	uint index = id;
		    
		    	
		    			uint instanceIndex, instanceActiveIndex, instanceCurrentIndex;
		    			index = VFXInitInstancing(index, instanceIndex, instanceActiveIndex, instanceCurrentIndex);
		    			
		    	GraphValues graphValues;
		    	
		    	graphValues._Color_a = asfloat(graphValuesBuffer.Load3(instanceActiveIndex * 240  + 176));
		    	graphValues._vfx_enabled_l = (bool)graphValuesBuffer.Load(instanceActiveIndex * 240  + 228);
		    	

		    
		    	struct ContextData
		    	{
		    	    uint maxParticleCount;
		    	    uint systemSeed;
		    	    uint initSpawnIndex;
		    	};
		    	ContextData contextData;
		    	uint4 rawContextData = graphValuesBuffer.Load4(instanceActiveIndex * 240);
		    	contextData.maxParticleCount = rawContextData.x;
		    	contextData.systemSeed = rawContextData.y;
		    	contextData.initSpawnIndex = rawContextData.z;
		    	

		    	uint systemSeed = contextData.systemSeed;
		    	uint nbMax = contextData.maxParticleCount;
		    
		    	
		    			#if HAS_STRIPS && !VFX_HAS_INDIRECT_DRAW
		    				// We render one particle less for each strip in this case
		    				nbMax -= STRIP_COUNT;
		    			#endif
		    			
		    			uint deadCount = 0;
		    			#if USE_DEAD_LIST_COUNT
		    			deadCount = deadList[instanceIndex];
		    			#endif
		    			#if VFX_USE_INSTANCING
		    			if (index >= nbMax - deadCount)
		    			#else
		    			if (index >= asuint(nbMax) - deadCount)
		    			#endif
		    			{
		    				CULL_VERTEX(o);
		    			}
		    			
		    			VFXAttributes attributes = (VFXAttributes)0;
		    			VFXSourceAttributes sourceAttributes = (VFXSourceAttributes)0;
		    			
		    			#if VFX_HAS_INDIRECT_DRAW
		    			if (index >= indirectBuffer[instanceActiveIndex])
		    			{
		    				CULL_VERTEX(o);
		    			}
		    			index = indirectBuffer[VFXGetIndirectBufferIndex(index, instanceActiveIndex)];
		    			#endif
		    			
		    			#if HAS_STRIPS_DATA
		    			StripData stripData;
		    			uint relativeIndexInStrip = 0;
		    			if (!FindIndexInStrip(index, id, instanceIndex, relativeIndexInStrip, stripData))
		    			{
		    				CULL_VERTEX(o);
		    			}
		    			#endif
		    			
		    			#if VFX_HAS_INDIRECT_DRAW
		    			attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
		    			attributes.color = float3(1, 1, 1);
		    			attributes.alpha = (float)1;
		    			attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
		    			attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
		    			
		    	
		    			#else
		    			attributes.alive = (attributeBuffer.Load(((instanceIndex * 0x7C940) + (index * 0x4 + 0x3)) << 2));
		    			
		    	
		    			#if !HAS_STRIPS
		    			if (!attributes.alive)
		    			{
		    				CULL_VERTEX(o);
		    			}
		    			#endif
		    			
		    			attributes.position = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x0)) << 2));
		    			attributes.color = float3(1, 1, 1);
		    			attributes.alpha = (float)1;
		    			attributes.oldPosition = asfloat(attributeBuffer.Load3(((instanceIndex * 0x7C940) + (index * 0x4 + 0x5F440)) << 2));
		    			
		    	
		    			#endif
		    			
		    			// Initialize built-in needed attributes
		    			#if HAS_STRIPS_DATA
		    			InitStripAttributes(index, attributes, stripData);
		    			#endif
		    			
		    	if (graphValues._vfx_enabled_l)
		    	{
		    	    SetAttribute_FDD06EC7( /*inout */attributes.color, graphValues._Color_a);
		    	}
		    	

		    
		    	if (!attributes.alive)
		    	{
		    		o.pos.x = VFX_NAN;
		    		return o; // cull
		    	}
		    
		    	float3 inputVertexPosition = float3(0.0f, 0.0f, 0.0f);
		    	float3 vPos = attributes.position;
		    	o.VFX_VARYING_POSCS = TransformPositionVFXToClip(vPos);
		    
		    	
		    			#if VFX_FEATURE_MOTION_VECTORS && defined(VFX_VARYING_VELOCITY_CPOS_PREVIOUS) && defined(VFX_VARYING_VELOCITY_CPOS)
		    			
		    			#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
		    				o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = (float2)0.0f;
		    			#else
		    				o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = o.VFX_VARYING_VELOCITY_CPOS = float4(0.0f, 0.0f, 0.0f, 1.0f);
		    			#endif
		    			
		    			
		    			uint elementToVFXBaseIndex;
		    			if (TryGetElementToVFXBaseIndex(index, instanceIndex, elementToVFXBaseIndex, currentFrameIndex))
		    			{
		    			float4 cPos = TransformPositionVFXToNonJitteredClip(vPos);
		    			
		    			#ifdef VFX_FEATURE_MOTION_VECTORS_VERTS
		    				o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = VFXGetPreviousClipPosition(elementToVFXBaseIndex, id).xy;
		    				o.VFX_VARYING_VELOCITY_CPOS = cPos.xy / cPos.w;
		    			#else
		    				float4x4 previousElementToVFX = VFXGetPreviousElementToVFX(elementToVFXBaseIndex);
		    				float3 oldvPos = mul(previousElementToVFX, float4(inputVertexPosition, 1.0f)).xyz;
		    				o.VFX_VARYING_VELOCITY_CPOS_PREVIOUS = TransformPositionVFXToPreviousClip(oldvPos);
		    				o.VFX_VARYING_VELOCITY_CPOS = cPos;
		    			#endif
		    			
		    			}
		    			#endif
		    			
		    	
		    			#if VFX_USE_COLOR_CURRENT && defined(VFX_VARYING_COLOR)
		    			o.VFX_VARYING_COLOR = attributes.color;
		    			#endif
		    			#if VFX_USE_ALPHA_CURRENT && defined(VFX_VARYING_ALPHA)
		    			o.VFX_VARYING_ALPHA = attributes.alpha;
		    			#endif
		    			
		    			#ifdef VFX_VARYING_EXPOSUREWEIGHT
		    			
		    			o.VFX_VARYING_EXPOSUREWEIGHT = exposureWeight;
		    			#endif
		    			
		    			#if USE_SOFT_PARTICLE && defined(VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE)
		    			
		    			o.VFX_VARYING_INVSOFTPARTICLEFADEDISTANCE = invSoftParticlesFadeDistance;
		    			#endif
		    			
		    			#if (USE_ALPHA_TEST || VFX_FEATURE_MOTION_VECTORS_FORWARD) && (!VFX_SHADERGRAPH || !HAS_SHADERGRAPH_PARAM_ALPHACLIPTHRESHOLD) && defined(VFX_VARYING_ALPHATHRESHOLD)
		    			
		    			o.VFX_VARYING_ALPHATHRESHOLD = alphaThreshold;
		    			#endif
		    			
		    			#if USE_UV_SCALE_BIAS
		    			
		    			
		    			#if defined (VFX_VARYING_UV)
		    			o.VFX_VARYING_UV.xy = o.VFX_VARYING_UV.xy * uvScale + uvBias;
		    			#endif
		    			#endif
		    			
		    			#ifdef VFX_VARYING_ANGLEFADE
		    			
		    			o.VFX_VARYING_ANGLEFADE = angleFade;
		    			#endif
		    			
		    			#ifdef VFX_VARYING_FADEFACTOR
		    			
		    			o.VFX_VARYING_FADEFACTOR = fadeFactor;
		    			#endif
		    			
		    			#ifdef VFX_VARYING_DECALLAYER
		    			
		    			o.VFX_VARYING_DECALLAYER = decalLayerMask;
		    			#endif
		    			
		    			#if defined(VFX_VARYING_POSWS)
		    			o.VFX_VARYING_POSWS = TransformPositionVFXToWorld(vPos);
		    			#endif
		    			
		    			#if VFX_USE_INSTANCING
		    			    #ifdef UNITY_INSTANCING_ENABLED
		    			    o.VFX_VARYINGS_INSTANCE_CURRENT_INDEX = unity_InstanceID;
		    			    #endif
		    			o.VFX_VARYINGS_INSTANCE_ACTIVE_INDEX = instanceActiveIndex;
		    			#endif
		    			
		    	
		    			    
		    			    		#if !defined(SHADER_API_METAL)
		    			    		    if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VERTEX_DENSITY)
		    			    		        IncrementVertexDensityCounter(o.VFX_VARYING_POSCS);
		    			    		#endif
		    			    		
		    			    
		    
		        o.pointSize = 1;
		    
		    	return o;
		    }
		    
		
		
		    
		    		    #pragma fragment frag
		    		    [earlydepthstencil]
		    		    void frag(ps_input i
		    		#if defined(PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER)
		    		            , uint primitiveId : SV_PrimitiveID
		    		#endif
		    		    )
		    		    {
		    		        UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
		    		        VFXTransformPSInputs(i);
		    		        VFX_FRAG_SETUP_INSTANCE_ID(i);
		    		        
		    		#ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER
		    		        if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)
		    		        {
		    		           IncrementQuadOverdrawCounter((uint2)i.VFX_VARYING_POSCS.xy, primitiveId);
		    		        }
		    		#endif
		    		    }
		    		
		
		    ENDHLSL
		}
		

		
	}
}
